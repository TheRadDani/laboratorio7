<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lista Enlazada: src/src/lista.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lista Enlazada
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Proyecto que implementa una lista enlazada</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('lista_8c.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lista.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="lista_8h_source.html">lista.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf5cb607734212671fe18b645cd073ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#adf5cb607734212671fe18b645cd073ab">push_back</a> (<a class="el" href="structnode.html">node</a> *head, int new_value)</td></tr>
<tr class="memdesc:adf5cb607734212671fe18b645cd073ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna valor para indicar si la insercion de un elemento al final de la lista fue exitosa.  <a href="lista_8c.html#adf5cb607734212671fe18b645cd073ab">More...</a><br /></td></tr>
<tr class="separator:adf5cb607734212671fe18b645cd073ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9c7e0b8129d93f5bbcb93faff9b12b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a0f9c7e0b8129d93f5bbcb93faff9b12b">push_front</a> (<a class="el" href="structnode.html">node</a> **head, int new_value)</td></tr>
<tr class="memdesc:a0f9c7e0b8129d93f5bbcb93faff9b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna entero que indica si a insercion de un elemento en la cabeza de la lista fue correcta.  <a href="lista_8c.html#a0f9c7e0b8129d93f5bbcb93faff9b12b">More...</a><br /></td></tr>
<tr class="separator:a0f9c7e0b8129d93f5bbcb93faff9b12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07abfbf24b9b9faf3d667b11b40c098c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a07abfbf24b9b9faf3d667b11b40c098c">printElement</a> (int value)</td></tr>
<tr class="memdesc:a07abfbf24b9b9faf3d667b11b40c098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imprime cada elemento del nodo que contiene la lista.  <a href="lista_8c.html#a07abfbf24b9b9faf3d667b11b40c098c">More...</a><br /></td></tr>
<tr class="separator:a07abfbf24b9b9faf3d667b11b40c098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f8ce2449e2f72da0ee5ab08f05d18a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a26f8ce2449e2f72da0ee5ab08f05d18a">readList</a> (const char *filePath)</td></tr>
<tr class="memdesc:a26f8ce2449e2f72da0ee5ab08f05d18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lectura del archivo binario que se escribe con la lista.  <a href="lista_8c.html#a26f8ce2449e2f72da0ee5ab08f05d18a">More...</a><br /></td></tr>
<tr class="separator:a26f8ce2449e2f72da0ee5ab08f05d18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cc8e670bdaf22947b98a3f5b9f2335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a68cc8e670bdaf22947b98a3f5b9f2335">writeList</a> (<a class="el" href="structnode.html">node</a> *head, const char *filePath)</td></tr>
<tr class="memdesc:a68cc8e670bdaf22947b98a3f5b9f2335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escritura de lista enlazada dentro de archivo binario.  <a href="lista_8c.html#a68cc8e670bdaf22947b98a3f5b9f2335">More...</a><br /></td></tr>
<tr class="separator:a68cc8e670bdaf22947b98a3f5b9f2335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39e2cf3835fa7fa0c1393a90fe5a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a0d39e2cf3835fa7fa0c1393a90fe5a58">createList</a> (int first_value)</td></tr>
<tr class="memdesc:a0d39e2cf3835fa7fa0c1393a90fe5a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un nodo en la lista.  <a href="lista_8c.html#a0d39e2cf3835fa7fa0c1393a90fe5a58">More...</a><br /></td></tr>
<tr class="separator:a0d39e2cf3835fa7fa0c1393a90fe5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b19bd8cd20f1362308a1bf565947bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a5b19bd8cd20f1362308a1bf565947bad">insertElement</a> (<a class="el" href="structnode.html">node</a> **phead, int pos, int new_value)</td></tr>
<tr class="memdesc:a5b19bd8cd20f1362308a1bf565947bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta elementos en lista segun valor y posicion.  <a href="lista_8c.html#a5b19bd8cd20f1362308a1bf565947bad">More...</a><br /></td></tr>
<tr class="separator:a5b19bd8cd20f1362308a1bf565947bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da4a2bbdf59b4e069d3819973f03b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a8da4a2bbdf59b4e069d3819973f03b43">printList</a> (<a class="el" href="structnode.html">node</a> *head)</td></tr>
<tr class="memdesc:a8da4a2bbdf59b4e069d3819973f03b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion imprime todos los elementos de la lista.  <a href="lista_8c.html#a8da4a2bbdf59b4e069d3819973f03b43">More...</a><br /></td></tr>
<tr class="separator:a8da4a2bbdf59b4e069d3819973f03b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f2ac46d0f2f636ebaa7df78bb8a8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a17f2ac46d0f2f636ebaa7df78bb8a8d3">freeList</a> (<a class="el" href="structnode.html">node</a> *head)</td></tr>
<tr class="memdesc:a17f2ac46d0f2f636ebaa7df78bb8a8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libera la memoria reservada por la lista.  <a href="lista_8c.html#a17f2ac46d0f2f636ebaa7df78bb8a8d3">More...</a><br /></td></tr>
<tr class="separator:a17f2ac46d0f2f636ebaa7df78bb8a8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5e23ece0ce006bcc168898f11dd9a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a7c5e23ece0ce006bcc168898f11dd9a5">sort</a> (<a class="el" href="structnode.html">node</a> *head, char dir)</td></tr>
<tr class="memdesc:a7c5e23ece0ce006bcc168898f11dd9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordenamiento de la lista en orden ascentente o descendente.  <a href="lista_8c.html#a7c5e23ece0ce006bcc168898f11dd9a5">More...</a><br /></td></tr>
<tr class="separator:a7c5e23ece0ce006bcc168898f11dd9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef29e110d8f78acee714a69c5c8a8190"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#aef29e110d8f78acee714a69c5c8a8190">pop_front</a> (<a class="el" href="structnode.html">node</a> **phead)</td></tr>
<tr class="memdesc:aef29e110d8f78acee714a69c5c8a8190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion elimina el primer elemento de la lista y sustiitute el elemento del dato del primero por el siguiente para que siga siendo una lista en lazada.  <a href="lista_8c.html#aef29e110d8f78acee714a69c5c8a8190">More...</a><br /></td></tr>
<tr class="separator:aef29e110d8f78acee714a69c5c8a8190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf20e4e03c1c6e2da0f6868efa2201e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#abf20e4e03c1c6e2da0f6868efa2201e9">pop_back</a> (<a class="el" href="structnode.html">node</a> *head)</td></tr>
<tr class="memdesc:abf20e4e03c1c6e2da0f6868efa2201e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion que elimina el ultimo elemento de la lista.  <a href="lista_8c.html#abf20e4e03c1c6e2da0f6868efa2201e9">More...</a><br /></td></tr>
<tr class="separator:abf20e4e03c1c6e2da0f6868efa2201e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49baab641bbedc4d8d28d18467543296"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#a49baab641bbedc4d8d28d18467543296">removeElement</a> (<a class="el" href="structnode.html">node</a> **phead, int pos)</td></tr>
<tr class="memdesc:a49baab641bbedc4d8d28d18467543296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina un elemento segun la posicion que se le indique.  <a href="lista_8c.html#a49baab641bbedc4d8d28d18467543296">More...</a><br /></td></tr>
<tr class="separator:a49baab641bbedc4d8d28d18467543296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef36177db50c48346bbcee2e0596a7e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lista_8c.html#aef36177db50c48346bbcee2e0596a7e7">getElement</a> (<a class="el" href="structnode.html">node</a> *head, int index, int *valid)</td></tr>
<tr class="memdesc:aef36177db50c48346bbcee2e0596a7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returna valor de la lista segun la posicion que se indique.  <a href="lista_8c.html#aef36177db50c48346bbcee2e0596a7e7">More...</a><br /></td></tr>
<tr class="separator:aef36177db50c48346bbcee2e0596a7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0d39e2cf3835fa7fa0c1393a90fe5a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39e2cf3835fa7fa0c1393a90fe5a58">&#9670;&nbsp;</a></span>createList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* createList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crea un nodo en la lista. </p>
<p>Se crea el nodo cabeza, al cual se le inserta en data el primer valor y el siguiente seria el NULL, ya que por definicion el ultimo elmento de una lista enlazada es el NULL para establecer condicion de parada. Este funciona para insertar mas nodos y crear la lista. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_value</td><td>Primer valor que contine el primer elemeto, es decir, la cabeza de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Devuelve un puntero a estructura node que corresponde a la definicion del nodo cabeza </dd></dl>

</div>
</div>
<a id="a17f2ac46d0f2f636ebaa7df78bb8a8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f2ac46d0f2f636ebaa7df78bb8a8d3">&#9670;&nbsp;</a></span>freeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Libera la memoria reservada por la lista. </p>
<p>Se crean dos punteros que apuntan a la estructura de tipo node y se llaman bor y reco, donde se recorre reco que es igual a head hasta que este no sea nulo y se recorre al siguiente y la primera instruccion correspode a liberar reco que la primera vez es la cabeza y luego el siguiente hasta liberar toda la memoria de la lista </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>recibe el puntero del primer elememto de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no tiene retorno </dd></dl>

</div>
</div>
<a id="aef36177db50c48346bbcee2e0596a7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef36177db50c48346bbcee2e0596a7e7">&#9670;&nbsp;</a></span>getElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returna valor de la lista segun la posicion que se indique. </p>
<p>Se crea un bucle que finaliza al llegar a la posicion del indice que corresponde a la posicion de la lista que se desea ontener el valor y al ser ese valor, el puntero nAux es igual a este ultimo y se obtene el valor del dato llamado y, al hacer que nAux apunte al dato de este puntero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>puntero al primer elemento de la lista </td></tr>
    <tr><td class="paramname">index</td><td>Posicion entera del elemento que se desea consultar en la lista. </td></tr>
    <tr><td class="paramname">valid</td><td>Recibe la direccion de una variable entera para modificarla a 1 si la posicion del elemento de la lista es exitosa, en caso contrario se retorna un 0 en caso que la posicion no exista o que la lista este vacia </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna el valor de la lista segun la posicion </dd></dl>

</div>
</div>
<a id="a5b19bd8cd20f1362308a1bf565947bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b19bd8cd20f1362308a1bf565947bad">&#9670;&nbsp;</a></span>insertElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> **&#160;</td>
          <td class="paramname"><em>phead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserta elementos en lista segun valor y posicion. </p>
<p>Si la posocion es uno, y lo sera en caso que no haya un elemnto ya en la lista, entonces inserta la estructura a node devuelta por create list y su ya esta creada, seguira insertando los elemntos y el ultimo sera NULL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pehead</td><td>recibe puntero al puntero de la cabeza de la lista </td></tr>
    <tr><td class="paramname">pos</td><td>posicion donde se quiere insertar el elemento en la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No tiene retorno </dd></dl>

</div>
</div>
<a id="abf20e4e03c1c6e2da0f6868efa2201e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf20e4e03c1c6e2da0f6868efa2201e9">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion que elimina el ultimo elemento de la lista. </p>
<p>elimina el último elemento de la lista y asigna al penúltimo elemento como el nuevo elemento del final y se suprimen posibles erreroes como el hecho que la lista cuente con un solo elemento y por ende no sea valido eliminar el ultimo. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>recibe el puntero cabeza de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna el valor entero del ultiomo elemento elimindao en la lista y si la lista esta vacia, se retorna un 1 </dd></dl>

</div>
</div>
<a id="aef29e110d8f78acee714a69c5c8a8190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef29e110d8f78acee714a69c5c8a8190">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> **&#160;</td>
          <td class="paramname"><em>phead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion elimina el primer elemento de la lista y sustiitute el elemento del dato del primero por el siguiente para que siga siendo una lista en lazada. </p>
<p>Se crea una variable de tipo entero que seaa igual al elemeto que apunta el primer elemento en la lista y se retorna este valor llamado informacion para saber cual era ese valor eliminado. Para que la lista siga siendo valida, es siguiente elemento, se guarda en una variable de tipo puntero el dato apuntarpo por el next de phead y este sustituye al phead que fue liberado anteriormente. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phead</td><td>recibe puntero doble del primer elemento de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>funcion no tiene retorno </dd></dl>

</div>
</div>
<a id="a07abfbf24b9b9faf3d667b11b40c098c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07abfbf24b9b9faf3d667b11b40c098c">&#9670;&nbsp;</a></span>printElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imprime cada elemento del nodo que contiene la lista. </p>
<p>Se crea la funcion de imprimir que recibe el valor que se desea imprimir de la lista. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>posicion del nodo que se quiere imprimir elemento </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no tiene retorno </dd></dl>

</div>
</div>
<a id="a8da4a2bbdf59b4e069d3819973f03b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da4a2bbdf59b4e069d3819973f03b43">&#9670;&nbsp;</a></span>printList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion imprime todos los elementos de la lista. </p>
<p>Mediante el puntero cabeza que se recibe como parametro, se guarda en n su contenido y se recorre n hasta que no sea nulo y por cada elemento se imprime el elemento segun la posicion de la lista. para esto se llama a la funcion printElement y se indica la posicion el elemento que se esta imprimiendo mediante un cantador. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Puntero del primer elemento de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No tiene retorno </dd></dl>

</div>
</div>
<a id="adf5cb607734212671fe18b645cd073ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5cb607734212671fe18b645cd073ab">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna valor para indicar si la insercion de un elemento al final de la lista fue exitosa. </p>
<p>Se recorre el puntero x que es igual a head y mientras este no sea nulo se recore todo, finalmente si luego de recorrer toa lista es NULL implica que no se pudo reservar la memoria y se retorna un 1. Si se pudo ingresar elemento al final es porque el final contiene data y el next wes NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>puntero a la cabeza de la lista </td></tr>
    <tr><td class="paramname">new_value</td><td>Valor que se anade al final de la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 0 si se pudo insertar un elemento de manera exitosa en la lista y un 1 si no es de esta manera </dd></dl>

</div>
</div>
<a id="a0f9c7e0b8129d93f5bbcb93faff9b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9c7e0b8129d93f5bbcb93faff9b12b">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> **&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna entero que indica si a insercion de un elemento en la cabeza de la lista fue correcta. </p>
<p>Esta funcion, crea un puntero nuevo que es al que se le reserva la lmemoria dinamica para asi hacer la revision y si este es NULL es porque no se pudo seservar memoria para este elemento y se hace el retorno de un 1. Caso contrario, el data apunta dentro de este del puntero cabeza, quire decir que se pudo reservar la memoria para que el puntero apunte a la estructura y se devuelve un 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>puntero al puntero del pirmer elemento de la lista </td></tr>
    <tr><td class="paramname">new_value</td><td>Elemento que se inserta en la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 0 si se pudo insertar un elemento de manera exitosa en la lista y un 1 si no es de esta manera </dd></dl>

</div>
</div>
<a id="a26f8ce2449e2f72da0ee5ab08f05d18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f8ce2449e2f72da0ee5ab08f05d18a">&#9670;&nbsp;</a></span>readList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* readList </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lectura del archivo binario que se escribe con la lista. </p>
<p>lee el archivo binario del disco duro y hace una lectura de elemento uno a uno hasta llegar al final de la llinea y se indica mediante un string explicitamente que es el contenido del archivo el que se esta leyendo y se imprime. se crea la condicion que sea mientra no se llegue a eol para que se lean todos los elementos y que ademas se reserva la memoria para que se recorrael documento una vez y no se imprima ningun elemento mas de una vez. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>nombre del archivo binario con la ruta </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returna un puntero a estructura con el primer elemento leido por la funcion </dd></dl>

</div>
</div>
<a id="a49baab641bbedc4d8d28d18467543296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49baab641bbedc4d8d28d18467543296">&#9670;&nbsp;</a></span>removeElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int removeElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> **&#160;</td>
          <td class="paramname"><em>phead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elimina un elemento segun la posicion que se le indique. </p>
<p>Se crea un contador para revisar la posicion del elemento que se quiere crear, ademas remueve elementos si y solo si la posicion indicada es menor o igual a la cantidad total de elementos en la lista. En caso de ser la primera posicon, se llama a la funcion pop_front. Si no es no es primero, se busca si es el ultimo o si esta en una posicion de en medio. si esta en medio, el siguiente sera el el elemnento que tenia el siguiente del eliminado y asi hasta llegar al ultimo elemento. Si es el ultimo, se remueve su valor y el siguiente del anterior sera NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phead</td><td>puntero al puntero de la cabeza de la lista </td></tr>
    <tr><td class="paramname">pos</td><td>posicion del elemento que se quiere eliminar en la lista </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorn el valor del dato que se elimino en la lista y en caso de no poderse realizar la operacion, devuelve un -1 </dd></dl>

</div>
</div>
<a id="a7c5e23ece0ce006bcc168898f11dd9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5e23ece0ce006bcc168898f11dd9a5">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordenamiento de la lista en orden ascentente o descendente. </p>
<p>Se hace reserva dinamica con malloc al puntero x que es un arreglo para la cantidad de enteros que contiene la lista y mediante un bucle, se le asigna a este el valor que contiene cada elemeto la lista. con el arreglo x[cant] listo con todos los elementos almacendos, se pone inserta el metodo burbuja para ordenar los elementos de x de forma descendete si el caracter de paramentro a si es b, se forma ascendentes. Esto se crea con un condicional, finalmente cuando los elementos ya estan ordenados, se imprimen enpantalla, separados por espacios y finalmente se libera la memoria. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>puntero al primer elemento de la lista </td></tr>
    <tr><td class="paramname">dir</td><td>variable tipo caracter que siendo a ordena la lista de forma descendente y si es b, la ordena de forma ascendente. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no tiene retorno </dd></dl>

</div>
</div>
<a id="a68cc8e670bdaf22947b98a3f5b9f2335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cc8e670bdaf22947b98a3f5b9f2335">&#9670;&nbsp;</a></span>writeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escritura de lista enlazada dentro de archivo binario. </p>
<p>Funcion recorre cada elemento dentro de la lista hasta llegar al ultimo elemento y por cada elemento lo escribe en la lista usando el metodo de escritura binaria con fwrite </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Puntero de la cabeza de la lista </td></tr>
    <tr><td class="paramname">filePath</td><td>Nombre del archivo binario con ruta </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no tiene retorno </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_98cdb10f369f6a3b9149e010b312bf5d.html">src</a></li><li class="navelem"><a class="el" href="lista_8c.html">lista.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
