<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="lista_8h" kind="file" language="C++">
    <compoundname>lista.h</compoundname>
    <includedby refid="lista_8c" local="yes">src/src/lista.c</includedby>
    <includedby refid="main_8c" local="yes">src/src/main.c</includedby>
    <invincdepgraph>
      <node id="2">
        <label>src/src/lista.c</label>
        <link refid="lista_8c"/>
      </node>
      <node id="3">
        <label>src/src/main.c</label>
        <link refid="main_8c"/>
      </node>
      <node id="1">
        <label>src/include/lista.h</label>
        <link refid="lista_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innerclass refid="structnode" prot="public">node</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="lista_8h_1aea2fb5b3fc96b5e6cbf434c978192a7a" prot="public" static="no">
        <name>NOMBRE</name>
        <initializer>&quot;listaEnlazada.bin&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="73" column="9" bodyfile="src/include/lista.h" bodystart="73" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="lista_8h_1ace29f146c273d2654669dc2c710603e2" prot="public" static="no">
        <type>struct <ref refid="structnode" kindref="compound">node</ref></type>
        <definition>typedef struct node  node</definition>
        <argsstring></argsstring>
        <name>node</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="79" column="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="lista_8h_1a26f8ce2449e2f72da0ee5ab08f05d18a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structnode" kindref="compound">node</ref> *</type>
        <definition>node* readList</definition>
        <argsstring>(const char *filePath)</argsstring>
        <name>readList</name>
        <param>
          <type>const char *</type>
          <declname>filePath</declname>
        </param>
        <briefdescription>
<para>Lectura del archivo binario que se escribe con la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>lee el archivo binario del disco duro y hace una lectura de elemento uno a uno hasta llegar al final de la llinea y se indica mediante un string explicitamente que es el contenido del archivo el que se esta leyendo y se imprime. se crea la condicion que sea mientra no se llegue a eol para que se lean todos los elementos y que ademas se reserva la memoria para que se recorrael documento una vez y no se imprima ningun elemento mas de una vez. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>nombre del archivo binario con la ruta </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>returna un puntero a estructura con el primer elemento leido por la funcion </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="88" column="6" bodyfile="src/src/lista.c" bodystart="45" bodyend="76" declfile="src/include/lista.h" declline="88" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a68cc8e670bdaf22947b98a3f5b9f2335" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void writeList</definition>
        <argsstring>(node *head, const char *filePath)</argsstring>
        <name>writeList</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>filePath</declname>
        </param>
        <briefdescription>
<para>Escritura de lista enlazada dentro de archivo binario. </para>
        </briefdescription>
        <detaileddescription>
<para>Funcion recorre cada elemento dentro de la lista hasta llegar al ultimo elemento y por cada elemento lo escribe en la lista usando el metodo de escritura binaria con fwrite <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>Puntero de la cabeza de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Nombre del archivo binario con ruta </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>no tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="97" column="6" bodyfile="src/src/lista.c" bodystart="78" bodyend="95" declfile="src/include/lista.h" declline="97" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1aef29e110d8f78acee714a69c5c8a8190" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int pop_front</definition>
        <argsstring>(node **phead)</argsstring>
        <name>pop_front</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> **</type>
          <declname>phead</declname>
        </param>
        <briefdescription>
<para>Funcion elimina el primer elemento de la lista y sustiitute el elemento del dato del primero por el siguiente para que siga siendo una lista en lazada. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crea una variable de tipo entero que seaa igual al elemeto que apunta el primer elemento en la lista y se retorna este valor llamado informacion para saber cual era ese valor eliminado. Para que la lista siga siendo valida, es siguiente elemento, se guarda en una variable de tipo puntero el dato apuntarpo por el next de phead y este sustituye al phead que fue liberado anteriormente. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>phead</parametername>
</parameternamelist>
<parameterdescription>
<para>recibe puntero doble del primer elemento de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>funcion no tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="106" column="5" bodyfile="src/src/lista.c" bodystart="247" bodyend="254" declfile="src/include/lista.h" declline="106" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1abf20e4e03c1c6e2da0f6868efa2201e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int pop_back</definition>
        <argsstring>(node *head)</argsstring>
        <name>pop_back</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <briefdescription>
<para>Funcion que elimina el ultimo elemento de la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>elimina el último elemento de la lista y asigna al penúltimo elemento como el nuevo elemento del final y se suprimen posibles erreroes como el hecho que la lista cuente con un solo elemento y por ende no sea valido eliminar el ultimo. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>recibe el puntero cabeza de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorna el valor entero del ultiomo elemento elimindao en la lista y si la lista esta vacia, se retorna un 1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="114" column="5" bodyfile="src/src/lista.c" bodystart="256" bodyend="290" declfile="src/include/lista.h" declline="114" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1adf5cb607734212671fe18b645cd073ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int push_back</definition>
        <argsstring>(node *head, int new_value)</argsstring>
        <name>push_back</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <param>
          <type>int</type>
          <declname>new_value</declname>
        </param>
        <briefdescription>
<para>Retorna valor para indicar si la insercion de un elemento al final de la lista fue exitosa. </para>
        </briefdescription>
        <detaileddescription>
<para>Se recorre el puntero x que es igual a head y mientras este no sea nulo se recore todo, finalmente si luego de recorrer toa lista es NULL implica que no se pudo reservar la memoria y se retorna un 1. Si se pudo ingresar elemento al final es porque el final contiene data y el next wes NULL. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>puntero a la cabeza de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Valor que se anade al final de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorna un 0 si se pudo insertar un elemento de manera exitosa en la lista y un 1 si no es de esta manera </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="124" column="5" bodyfile="src/src/lista.c" bodystart="5" bodyend="24" declfile="src/include/lista.h" declline="124" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a0f9c7e0b8129d93f5bbcb93faff9b12b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int push_front</definition>
        <argsstring>(node **head, int new_value)</argsstring>
        <name>push_front</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> **</type>
          <declname>head</declname>
        </param>
        <param>
          <type>int</type>
          <declname>new_value</declname>
        </param>
        <briefdescription>
<para>Retorna entero que indica si a insercion de un elemento en la cabeza de la lista fue correcta. </para>
        </briefdescription>
        <detaileddescription>
<para>Esta funcion, crea un puntero nuevo que es al que se le reserva la lmemoria dinamica para asi hacer la revision y si este es NULL es porque no se pudo seservar memoria para este elemento y se hace el retorno de un 1. Caso contrario, el data apunta dentro de este del puntero cabeza, quire decir que se pudo reservar la memoria para que el puntero apunte a la estructura y se devuelve un 0. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>puntero al puntero del pirmer elemento de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Elemento que se inserta en la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorna un 0 si se pudo insertar un elemento de manera exitosa en la lista y un 1 si no es de esta manera </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="134" column="5" bodyfile="src/src/lista.c" bodystart="26" bodyend="38" declfile="src/include/lista.h" declline="134" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a07abfbf24b9b9faf3d667b11b40c098c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void printElement</definition>
        <argsstring>(int value)</argsstring>
        <name>printElement</name>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Imprime cada elemento del nodo que contiene la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crea la funcion de imprimir que recibe el valor que se desea imprimir de la lista. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>posicion del nodo que se quiere imprimir elemento </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>no tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="142" column="6" bodyfile="src/src/lista.c" bodystart="40" bodyend="43" declfile="src/include/lista.h" declline="142" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a0d39e2cf3835fa7fa0c1393a90fe5a58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structnode" kindref="compound">node</ref> *</type>
        <definition>node* createList</definition>
        <argsstring>(int first_value)</argsstring>
        <name>createList</name>
        <param>
          <type>int</type>
          <declname>first_value</declname>
        </param>
        <briefdescription>
<para>Crea un nodo en la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crea el nodo cabeza, al cual se le inserta en data el primer valor y el siguiente seria el NULL, ya que por definicion el ultimo elmento de una lista enlazada es el NULL para establecer condicion de parada. Este funciona para insertar mas nodos y crear la lista. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Primer valor que contine el primer elemeto, es decir, la cabeza de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Devuelve un puntero a estructura node que corresponde a la definicion del nodo cabeza </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="151" column="6" bodyfile="src/src/lista.c" bodystart="97" bodyend="108" declfile="src/include/lista.h" declline="151" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a5b19bd8cd20f1362308a1bf565947bad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void insertElement</definition>
        <argsstring>(node **phead, int pos, int new_value)</argsstring>
        <name>insertElement</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> **</type>
          <declname>phead</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>int</type>
          <declname>new_value</declname>
        </param>
        <briefdescription>
<para>Inserta elementos en lista segun valor y posicion. </para>
        </briefdescription>
        <detaileddescription>
<para>Si la posocion es uno, y lo sera en caso que no haya un elemnto ya en la lista, entonces inserta la estructura a node devuelta por create list y su ya esta creada, seguira insertando los elemntos y el ultimo sera NULL <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pehead</parametername>
</parameternamelist>
<parameterdescription>
<para>recibe puntero al puntero de la cabeza de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>posicion donde se quiere insertar el elemento en la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>No tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="160" column="6" bodyfile="src/src/lista.c" bodystart="110" bodyend="157" declfile="src/include/lista.h" declline="160" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a8da4a2bbdf59b4e069d3819973f03b43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void printList</definition>
        <argsstring>(node *head)</argsstring>
        <name>printList</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <briefdescription>
<para>Funcion imprime todos los elementos de la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>Mediante el puntero cabeza que se recibe como parametro, se guarda en n su contenido y se recorre n hasta que no sea nulo y por cada elemento se imprime el elemento segun la posicion de la lista. para esto se llama a la funcion printElement y se indica la posicion el elemento que se esta imprimiendo mediante un cantador. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>Puntero del primer elemento de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>No tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="169" column="6" bodyfile="src/src/lista.c" bodystart="159" bodyend="172" declfile="src/include/lista.h" declline="169" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a17f2ac46d0f2f636ebaa7df78bb8a8d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void freeList</definition>
        <argsstring>(node *head)</argsstring>
        <name>freeList</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <briefdescription>
<para>Libera la memoria reservada por la lista. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crean dos punteros que apuntan a la estructura de tipo node y se llaman bor y reco, donde se recorre reco que es igual a head hasta que este no sea nulo y se recorre al siguiente y la primera instruccion correspode a liberar reco que la primera vez es la cabeza y luego el siguiente hasta liberar toda la memoria de la lista <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>recibe el puntero del primer elememto de la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>no tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="177" column="6" bodyfile="src/src/lista.c" bodystart="174" bodyend="185" declfile="src/include/lista.h" declline="177" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a7c5e23ece0ce006bcc168898f11dd9a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void sort</definition>
        <argsstring>(node *head, char dir)</argsstring>
        <name>sort</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <param>
          <type>char</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
<para>Ordenamiento de la lista en orden ascentente o descendente. </para>
        </briefdescription>
        <detaileddescription>
<para>Se hace reserva dinamica con malloc al puntero x que es un arreglo para la cantidad de enteros que contiene la lista y mediante un bucle, se le asigna a este el valor que contiene cada elemeto la lista. con el arreglo x[cant] listo con todos los elementos almacendos, se pone inserta el metodo burbuja para ordenar los elementos de x de forma descendete si el caracter de paramentro a si es b, se forma ascendentes. Esto se crea con un condicional, finalmente cuando los elementos ya estan ordenados, se imprimen enpantalla, separados por espacios y finalmente se libera la memoria. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>puntero al primer elemento de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>variable tipo caracter que siendo a ordena la lista de forma descendente y si es b, la ordena de forma ascendente. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>no tiene retorno </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="188" column="6" bodyfile="src/src/lista.c" bodystart="187" bodyend="245" declfile="src/include/lista.h" declline="188" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1a49baab641bbedc4d8d28d18467543296" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int removeElement</definition>
        <argsstring>(node **phead, int pos)</argsstring>
        <name>removeElement</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> **</type>
          <declname>phead</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Elimina un elemento segun la posicion que se le indique. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crea un contador para revisar la posicion del elemento que se quiere crear, ademas remueve elementos si y solo si la posicion indicada es menor o igual a la cantidad total de elementos en la lista. En caso de ser la primera posicon, se llama a la funcion pop_front. Si no es no es primero, se busca si es el ultimo o si esta en una posicion de en medio. si esta en medio, el siguiente sera el el elemnento que tenia el siguiente del eliminado y asi hasta llegar al ultimo elemento. Si es el ultimo, se remueve su valor y el siguiente del anterior sera NULL. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>phead</parametername>
</parameternamelist>
<parameterdescription>
<para>puntero al puntero de la cabeza de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>posicion del elemento que se quiere eliminar en la lista </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorn el valor del dato que se elimino en la lista y en caso de no poderse realizar la operacion, devuelve un -1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="200" column="5" bodyfile="src/src/lista.c" bodystart="292" bodyend="331" declfile="src/include/lista.h" declline="200" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="lista_8h_1aef36177db50c48346bbcee2e0596a7e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int getElement</definition>
        <argsstring>(node *head, int index, int *valid)</argsstring>
        <name>getElement</name>
        <param>
          <type><ref refid="structnode" kindref="compound">node</ref> *</type>
          <declname>head</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>valid</declname>
        </param>
        <briefdescription>
<para>Returna valor de la lista segun la posicion que se indique. </para>
        </briefdescription>
        <detaileddescription>
<para>Se crea un bucle que finaliza al llegar a la posicion del indice que corresponde a la posicion de la lista que se desea ontener el valor y al ser ese valor, el puntero nAux es igual a este ultimo y se obtene el valor del dato llamado y, al hacer que nAux apunte al dato de este puntero <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>head</parametername>
</parameternamelist>
<parameterdescription>
<para>puntero al primer elemento de la lista </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Posicion entera del elemento que se desea consultar en la lista. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>valid</parametername>
</parameternamelist>
<parameterdescription>
<para>Recibe la direccion de una variable entera para modificarla a 1 si la posicion del elemento de la lista es exitosa, en caso contrario se retorna un 0 en caso que la posicion no exista o que la lista este vacia </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorna el valor de la lista segun la posicion </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/include/lista.h" line="210" column="5" bodyfile="src/src/lista.c" bodystart="333" bodyend="353" declfile="src/include/lista.h" declline="210" declcolumn="5"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Funcion principal. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="version"><para>1.0 </para>
</simplesect>
<simplesect kind="date"><para>24/02/2021</para>
</simplesect>
Funcion principal que llama a las funciones de la biblioteca lista. para asi ejecutar los metodos sobre l lista enlazada que se crea a a partir del puntero a lista llamado cabeza en el main. Se crean condicionales para comprobar si los eleemntos estan en la lista o si la operacion es valida en la lista actual. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Argumentos</parametername>
</parameternamelist>
<parameterdescription>
<para>de entrada </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Retorno de entero 0 <programlisting><codeline><highlight class="normal"><sp/>int<sp/>main(int<sp/>argc,<sp/>char<sp/>**argv,<sp/>char<sp/>const<sp/>**envp)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>argc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>argv;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>envp;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>elemento=1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>valid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node<sp/>*cabeza<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insertElement(&amp;cabeza,<sp/>1,<sp/>10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insertElement(&amp;cabeza,<sp/>2,<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insertElement(&amp;cabeza,3,9);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>writeList(cabeza,<sp/>NOMBRE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node<sp/>*nuevaLista<sp/>=<sp/>readList(NOMBRE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;lista<sp/>leida<sp/>del<sp/>archivo\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printList(nuevaLista);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;lista<sp/>creada<sp/>con<sp/>codigo<sp/>en<sp/>main\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>push_back(cabeza,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>push_front(&amp;cabeza,<sp/>500);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printList(cabeza);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;\nEl<sp/>elemento<sp/>en<sp/>la<sp/>posicion<sp/>%i<sp/>es<sp/>%i\n&quot;,elemento,getElement(cabeza,<sp/>elemento,<sp/>&amp;valid));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(valid==0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Elemento<sp/>no<sp/>valido\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if(valid==1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Elemento<sp/>valido\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;\nLista<sp/>luego<sp/>de<sp/>eliminar<sp/>elemento\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>a=removeElement(&amp;cabeza,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printList(cabeza);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;\nEl<sp/>elemento<sp/>eliminado<sp/>fue:<sp/>%i\n&quot;,a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;\nLista<sp/>luego<sp/>de<sp/>eliminar<sp/>el<sp/>ultimo<sp/>elemento\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>b=pop_back(cabeza);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(b!=-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printList(cabeza);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;El<sp/>ultimo<sp/>elemento<sp/>en<sp/>eliminarse<sp/>fue<sp/>%i\n&quot;,b);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;La<sp/>lista<sp/>esta<sp/>vacia\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;La<sp/>lista<sp/>ordenada<sp/>de<sp/>manera<sp/>descendente<sp/>es:<sp/>\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//fflush(stdout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sort(cabeza,<sp/>&apos;a&apos;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;\nLa<sp/>lista<sp/>ordenada<sp/>de<sp/>manera<sp/>ascendente<sp/>es:<sp/>\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sort(cabeza,<sp/>&apos;b&apos;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>freeList(cabeza);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"></codeline>
<codeline lineno="70"><highlight class="preprocessor">#ifndef<sp/>LISTA_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LISTA_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight></codeline>
<codeline lineno="73" refid="lista_8h_1aea2fb5b3fc96b5e6cbf434c978192a7a" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NOMBRE<sp/>&quot;listaEnlazada.bin&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75" refid="structnode" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structnode" kindref="compound">node</ref></highlight></codeline>
<codeline lineno="76"><highlight class="normal">{</highlight></codeline>
<codeline lineno="77" refid="structnode_1a9eab91667db4d35c7231dcddf7b89a76" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="structnode_1a9eab91667db4d35c7231dcddf7b89a76" kindref="member">data</ref>;<sp/></highlight></codeline>
<codeline lineno="78" refid="structnode_1a0dc1b6470487aa86d9936e3cab8b95be" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structnode" kindref="compound">node</ref><sp/>*<ref refid="structnode_1a0dc1b6470487aa86d9936e3cab8b95be" kindref="member">next</ref>;<sp/></highlight></codeline>
<codeline lineno="79"><highlight class="normal">}<sp/><ref refid="lista_8h_1ace29f146c273d2654669dc2c710603e2" kindref="member">node</ref>;</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><ref refid="structnode" kindref="compound">node</ref><sp/>*<ref refid="lista_8h_1a26f8ce2449e2f72da0ee5ab08f05d18a" kindref="member">readList</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*filePath);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a68cc8e670bdaf22947b98a3f5b9f2335" kindref="member">writeList</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*filePath);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1aef29e110d8f78acee714a69c5c8a8190" kindref="member">pop_front</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>**phead);</highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1abf20e4e03c1c6e2da0f6868efa2201e9" kindref="member">pop_back</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head);</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1adf5cb607734212671fe18b645cd073ab" kindref="member">push_back</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>new_value);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a0f9c7e0b8129d93f5bbcb93faff9b12b" kindref="member">push_front</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>**head,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>new_value);</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a07abfbf24b9b9faf3d667b11b40c098c" kindref="member">printElement</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>value);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"></highlight></codeline>
<codeline lineno="151"><highlight class="normal"><ref refid="structnode" kindref="compound">node</ref><sp/>*<ref refid="lista_8h_1a0d39e2cf3835fa7fa0c1393a90fe5a58" kindref="member">createList</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>first_value);</highlight></codeline>
<codeline lineno="152"><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a5b19bd8cd20f1362308a1bf565947bad" kindref="member">insertElement</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>**phead,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>pos,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>new_value);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a8da4a2bbdf59b4e069d3819973f03b43" kindref="member">printList</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head);</highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a17f2ac46d0f2f636ebaa7df78bb8a8d3" kindref="member">freeList</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head);</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a7c5e23ece0ce006bcc168898f11dd9a5" kindref="member">sort</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>dir);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1a49baab641bbedc4d8d28d18467543296" kindref="member">removeElement</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>**phead,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>pos);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="lista_8h_1aef36177db50c48346bbcee2e0596a7e7" kindref="member">getElement</ref>(<ref refid="structnode" kindref="compound">node</ref><sp/>*head,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>valid);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//<sp/>LISTA_H</highlight></codeline>
    </programlisting>
    <location file="src/include/lista.h"/>
  </compounddef>
</doxygen>
